url->	 https://www.tutorialspoint.com/spring/spring_transaction_management.htm -konu anlatýmý

Spring - Transaction Management- >
 
		Isolation, Propagation, Read-Only, TimeOut, Rollback
		
		1)Isolation ->
			Birden fazla iþlem ayný veriler üzerinde ayný anda çalýþabilir. Bu durumda bu iþlemlerin birbirine karýþmamasý gerekir.
			Ýþlemlerin karýþma durumunda belli problemlere yol açabilir.
			***Kendi fikrimce þöyle bir örnek verebilirim.
				-> Bir sinemaya gittiniz bilet alýcaksýnýz birden fazla satýþ danýþmaný oldugðunu varsayalým. Ayný anda iki kiþi ayný filmi farklý satýs 
				danýþmanlarýndan ayný koltuga talip oluyorlar. Birinci satýþ danýþmaný koltuga týklayýp rezervazyon yapýyorken ikinci satýþ danýþmanýda ondan 
				habersiz ayný koltuga týklayýp rezervasyon yapýyor. Bu durumda bir problem ortaya cýkýyor.
				Olmasý gereken birinci satýþ danýþmaný koltuga týkladýgýnda o koltuk kitlenmeli ve transaction iþlemi commit edilene kadar kitli kalmalý.
				
			Böyle durumlarda 3 tane problem cýkabilir.-> dirty-reads, nonrepeatable-reads, phantom-reads		
				
url->			http://www.byteslounge.com/tutorials/spring-transaction-isolation-tutorial
				
				1.1)dirty-reads(Kirli okuma) -> Ýki iþlem ayný veri üzerinde çalýþýrken birincisi veri üzerinde deðiþiklik yapýp daha commit etmeden ikinci iþlem 
											deðiþen veriyi alýp onu kullanmasý ve birinci iþlem bir hatayla karþýlaþýp iþlemleri geri almasý durumunda ikinci 
											iþlem bu geri almadan habersiz deðiþen veriyi kullanmasý durumu.
				
					Örnek olarak;  	int x = 5;
									1.kiþi -> x = 10 yapýyor.
									2.kiþi x = 10 iken x degerini iþlemlerinde kullanýyor.
									1.kiþi x = 10 ile baþlayýp ilerleyen iþlemlerinde hata ile karþýlaþýyor rollback yapýyor x = 5 eski haline dönüyor.
									2.kiþi bu iþlemden habersiz x=10 iken kullanarak iþlemlerin tutarsýzlýgýna yol acýyor(dirty-reads)
				
				1.2)nonrepatable-reads -> Bir kullanýcý veritabanýna gönderdiði her sorguda farklý sonuclar elde etmesi.
									Baþka bir kullanýcý birinci kullanýcýnýn her yaptýgý sorgularýn arasýna girerek farklý sorgular gönderip veriyi deðiþtirmesi
									nonrepeatable-reads hatasýna yol açar.
									
				1.3)phantom-reads -> nonrepatable-reads'a benzer Bir kullanýcý veritabanýna gönderdiði her sorguda ya yeni veriler eklenmiþ yada veriler eksilmiþ
									gibi cýkan sonuclardan ortaya cýkan hatadýr.
		
			Bu gibi hatalardan kacýnmak için Isolation seviyelerimizi ayarlýyabiliriz.
				Seviye sýralamasý (kücükten - büyüðe dogru) 
					-> read-uncommited , read-commited, repeatable-read, Seriazable
					
						1.a) read-uncommitted -> Bir iþlem commit edilmeden baþka bir iþlemin deðiþen verileri kullanmasý olayýdýr.
													Oluþabilecek hatalar -> dirty-reads, nonrepatable-reads, phantom-reads 									
									
						1.b) read-committed -> Ýsmindende anlaþýlacagý gibi committen sonra okuma. Çoðu veritanlarý tarafýnda default izolasyon seviyesidir.
												Oluþabilecek hatalar -> nonrepatable-reads, phantom-reads
						1.c) repeatable-read -> Ayný sorgularda hep ayný sonucu almayý saðlar.
												Oluþabilecek hatalar -> phantom-reads				
						1.d) Seriazable -> En yüksek seviyedir. Bütün hata türleri engellenir.
											Nasýl yapar : Bu isolation seviyesindeki transaction'ýn iþlem yaptýgý tüm toblolar kitlenir iþlemi bitene kadar
											ayný tablolar üzerinde iþlem yaptýrmaz. Bu nedenle en yavaþ olanýda budur.
											 
url->		http://docs.spring.io/spring/docs/current/spring-framework-reference/html/transaction.html ---propagation ara
		http://docs.spring.io/spring/docs/current/spring-framework-reference/html/transaction.html#tx-propagation
		2) Propagation -> 
					Bir transaction nasýl çalýþacagýný belirleyen olaydýr.
					Bir metod iþleminde(örnegin veritabanýna kayýt iþlemi) transaction içinde çalýþýp çalýþmayacagý var olan bir transaction kullanýp 
					kullanýlmayacagý yada var olan es gecilip yeni bir transaction yaratýlýp kullanýlacagý gibi durumlar belirlenir.
					Default olarak var olan kullanýlýr. yoksa oluþturulup kullanýlýr. 7 Seviyeden oluþur.
					
					propagation_required, propagation_requires_new, propagation_never, propagation_nested, propagation_mandatory, propagation_supports
					propagation_not_supports
						 	
		3) Read-Only -> 
					Adý üstünde sadece veri oku anlamýna gelmektedir. Herhangi bir update yada execute iþlemi yapmaz. Select için kullanýlabilir.
					Performans arttýrmak için kullanýlabilir.
		
		4) Time-Out -> 
					Adý üstünde zaman bitiþi diye türkceye cevirebiliriz.
					Bir transaction ne kadar sürede sonlandýrýlacagýný belirleyebiliriz.
					Time-Out Propagation_Required_New ile kullanýlmasý önerilir. Neden her transaction bir süresi olacagýndan var olan transaction
					degilde yeni bir transaction'ýn o süreyle baþlatýlýp sonlanmasý iyi olacaktýr.
		
		5) Roll-Back -> 
					Bilindiði üzere roll-back iþlemleri geri alma olarak bilinir. Spring default olarak RuntimeException veya onu kalýtan sýnýflardan oluþan
					hatalarda rollback yapar. Ama biz istegimize göre hata sýnýflarýmýz belirleyip o sýnýf ile hata oluþtugunda rollback yapabiliriz.
	
		Güzel bir örnek:

		Bu çalýþmayý ortaya koyan; Murat Yüzkollar, Fatma Elverir, Eren Kiraz, Ömer Hakan Bilici ve çalýþma grubu yöneticisi Alperen Paker’ 
		e kodcu.com olarak teþekkür ederiz.							
url->	https://blog.kodcu.com/2012/07/spring-transaction-yonetimi/
		
														 	
 						
									
				
	

	